<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>call , apply实现继承</title>
    <script type="text/javascript">
        function Person(name, age, love) {
            this.name = name;
            this.age = age;
            this.love = love;
            this.say = function say() {
                alert("姓名：" + name);
            }
        }

        //call方式
        function student(name, age) {
            Person.call(this, name, age);
        }

        //apply方式
        function teacher(name, love) {
            Person.apply(this, [name, love]);
            //Person.apply(this,arguments); //跟上句一样的效果，arguments
        }

        //call与aplly的异同：
        //1,第一个参数this都一样,指当前对象
        //2,第二个参数不一样：call的是一个个的参数列表；apply的是一个数组（arguments也可以）

        var per = new Person("武凤楼", 25, "魏荧屏"); //输出：“武凤楼”
        per.say();
        var stu = new student("曹玉", 18);//输出：“曹玉”
        stu.say();
        var tea = new teacher("秦杰", 16);//输出：“秦杰”
        tea.say();
    </script>
    <script type="text/javascript">
        function Person(name, age) {   //定义一个类
            this.name = name;     //名字
            this.age = age;       //年龄
            this.sayhello = function () { alert(this.name) };
        }
        function Print() {            //显示类的属性
            this.funcName = "Print";
            this.show = function () {
                var msg = [];
                for (var key in this) {
                    if (typeof (this[key]) != "function") {
                        msg.push([key, ":", this[key]].join(""));
                    }
                }
                alert(msg.join(" "));
            };
        }
        function Student(name, age, grade, school) {    //学生类
            Person.apply(this, arguments);//比call优越的地方
            Print.apply(this, arguments);
            this.grade = grade;                //年级
            this.school = school;                 //学校
        }
        var p1 = new Person("卜开化", 80);
        p1.sayhello();
        var s1 = new Student("白云飞", 40, 9, "岳麓书院");
        s1.show();
        s1.sayhello();
        alert(s1.funcName);
    </script>
    <script type="text/javascript">
        alert(Math.max(5, 8));   //8
        alert(Math.max(5, 7, 9, 3, 1, 6));   //9

        //但是在很多情况下，我们需要找出数组中最大的元素。

        var arr = [5, 7, 9, 1];
        //alert(Math.max(arr));    // 这样却是不行的。NaN

        //要这样写
        function getMax(arr) {
            var arrLen = arr.length;
            var ret = arr[0];
            for (var i = 0; i < arrLen; i++) {
                ret = Math.max(ret, arr[i]);
            }
            return ret;
        }

        alert(getMax(arr)); //9

        //换用apply，可以这样写
        function getMax2(arr) {
            return Math.max.apply(null, arr);
        }

        alert(getMax2(arr)); //9

        //两段代码达到了同样的目的，但是getMax2却优雅，高效，简洁得多。

        //再比如数组的push方法。
        var arr1 = [1, 3, 4];
        var arr2 = [3, 4, 5];
        //如果我们要把 arr2展开，然后一个一个追加到arr1中去，最后让arr1=[1,3,4,3,4,5]
        //arr1.push(arr2)显然是不行的。 因为这样做会得到[1,3,4,[3,4,5]]

        //我们只能用一个循环去一个一个的push(当然也可以用arr1.concat(arr2)，但是concat方法并不改变arr1本身)

        var arrLen = arr2.length;
        for (var i = 0; i < arrLen; i++) {
            arr1.push(arr2[i]);
        }

        //自从有了Apply,事情就变得如此简单

        Array.prototype.push.apply(arr1, arr2); //现在arr1就是想要的结果
    </script>
</head>
<body>
    <p>
        js中call和apply都可以实现继承，唯一的一点参数不同，func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3])。
    </p>
    <p>
        调用一个对象的一个方法，以另一个对象替换当前对象。
        如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。
    </p>
    <p>
        call([thisObj[,arg1[, arg2[,   [,.argN]]]]])
    </p>
    <table>
        <tr>
            <td>thisObj</td>
            <td>可选项。将被用作当前对象的对象。</td>
        </tr>
        <tr>
            <td>arg1, arg2,  , argN</td>
            <td>可选项。将被传递方法参数序列。</td>
        </tr>
        <tr>
            <td>说明</td>
            <td>
                call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。
            </td>
        </tr>
    </table>
</body>
</html>